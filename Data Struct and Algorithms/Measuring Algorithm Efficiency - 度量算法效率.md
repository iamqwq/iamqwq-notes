# Measuring Algorithm Efficiency - 度量算法效率

## 1 事后统计方法和事前分析估算方法

算法设计中有一条很重要的标准——时间效率高和存储量低。因此我们需要频繁的度量算法的效率以判断算法的优劣并进行改进。

将程序反复执行若干次，最终把平均的执行时间计算出来，这是我们能想到的最直观最简单的算法效率度量方法。又或许会想到能否通过一些公式化计算的方法在即使不执行代码的情况下也能度量算法效率。

类似前者所说的统计方法称作事后统计方法，但这有一些明显的缺陷：

1. 每次测算算法的执行效率时就要花费很多时间。
2. 统计出的结果也因硬件的不同而不同。

而后者所描述的方法是称作事前分析估算方法。

很明显的是事后统计方法有很大的局限性，对比之下应该采用事前分析估算方法。

## 2 时间复杂度和大 O 表示法

> 在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。
>
> 原文链接：https://zhuanlan.zhihu.com/p/50479555

明晰大 O 表示法的关键在于理解**渐进**二字。如果将关于输入规模 n 和对应的算法执行时间描述成函数之后，能够轻易的发现，当 n 增长到一定程度后，函数的常数项和最高次项系数甚至非最高次项都可以忽略不计。总结来说大 O 表示法实际上是描述算法增长趋势的方法。

大 O 表示复杂度的推算方法：

> 1. 用常数 1 取代运行时间中的所有加法常数。
> 2. 在修改后的运行次数中，只保留最高阶项。
> 3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。

为理解这种表示方法的推算，我在下面举例表示常见的复杂度代码。大 O 表示法有几种常见的复杂度：

1. 常数阶

   ```java
   int i = 0;
   System.out.println(i);
   ```

   这段两行的代码共进行了 2 次操作，因此我们将 2 根据规则变为 1，此外也没有最高次项，因此时间复杂度为 O(1)。

2. 线性阶

   ```java
   for(int i = 0; i < n; i++) {
       System.out.println(i);
   }
   ```

   循环中的代码共进行了 n 次，因此时间复杂度为 O(n)。

3. 对数阶

   ```java
   int a = 1;
   while(a < n) {
       a *= 2;
   }
   ```

   很明显，每次循环都会让 a 翻一倍，时间复杂度为 O(logn)。是 logn 而不是 log2n 的原因是因为不论底数是多少，他们的渐进增长趋势是差不多的。

4. nlogn 阶

5. 平方阶

   ```java
   for(int i = 0; i < n; i++) {
       for(int j = 0; j < n; j++) {
           System.out.println(i + " " + j);
       }
   }
   ```

   这段代码的时间复杂度则是 O(n^2)。

6. 立方阶

   ```java
   for(int i = 0; i < n; i++) {
       for(int j = 0; j < n; j++) {
           for(int k = 0; k < n; k++) {
               System.out.println(i + " " + j + " " + k);
           }
       }
   }
   ```

   这段代码的时间复杂度则是 O(n^3)。

7. 指数阶

   



