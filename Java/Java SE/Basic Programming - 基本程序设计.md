

# Basic Programming - 基本程序设计

## 1 数据类型

从 Java （变量的）数据类型上可以分为 Java 的内置数据类型以及引用数据类型两大类，不过在这之前需要讨论一下变量和（变量的）数据类型的相关需要了解的东西。

### 1. 1 变量和数据类型

#### 1. 1. 1 概述

变量可以看作是一个容器，用于存放数据；这个容器需要提前申请，并且不同类型的容器存放不同类型的数据。不抽象的说即是当需要使用各种量来进行运算并储存他们的结果的时候，我们采用定义变量的方式解决存储数据的问题，这个定义的过程中计算机会根据数据的类型分配相应大小的空间给变量。

#### 1. 1. 2 变量命名和定义

变量的命名有着强制的规则，即字母开头 + 字母和数字的组合。这里的 "字母" 除大小写的 26 个拉丁字母以外还包括 "_"、"$"。

> . . .
>
> 但是不要在你自己的代码中使用 \$ 这个字符。它只用在 Java 编译器或其它工具生成的名字中。
>
> . . .
>
> 另外，不能使用 Java 保留字作为变量名。
>
> 在 Java 9 中，单下划线 _ 不能作为变量名。
>
> . . .

变量定义时一般使用 Type Varible = Value; 这种格式。

> 可以在一行中声明多个变量：
>
> int i, j;
>
> 不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。

在上引文和上文中出现了 "声明" 和 "定义" 两种不同的用词，实际上，Java 不区分变量的声明和定义。另外，《 Java 核心技术 》中写道：

> 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。例如，Java 编译器认为下面的语句序列是错误的：
>
> ```java
> int vacationDays;
> System.out.println(vacationDays); // ERROR--variable not initialized
> ```

对变量进行初始化是一个必要的习惯。但是菜鸟中有一个类型默认值的说法：

> #### 类型默认值
>
> 下表列出了 Java 各个类型的默认值：
>
> | **数据类型**           | **默认值** |
> | :--------------------- | :--------- |
> | byte                   | 0          |
> | short                  | 0          |
> | int                    | 0          |
> | long                   | 0L         |
> | float                  | 0.0f       |
> | double                 | 0.0d       |
> | char                   | 'u0000'    |
> | String (or any object) | null       |
> | boolean                | false      |

那么既然类型有默认值，为什么编译器还会认为是错误的？我们将在 2 Variable Type - 变量类型 这一节进行讨论。

需要注意的是 C 或 C++ 会根据处理器选择最高效的类型大小，但是 Java 并不会这么干，这意味着在任何平台上 int 型的变量永远是 4 字节（数据类型有着固定的长度）。

Java是强类型语言（LINKHERE），因此 Java 的每一个变量都使用一种类型。

### 1. 2 内置数据类型

#### 1. 2. 1 对于整数

Java 拥有四种用于表示整数的类型。

| Type Name | Type Size |
| :-------: | :-------: |
|   byte    |  1 byte   |
|   short   |  2 bytes  |
|    int    |  4 bytes  |
|   long    |  8 bytes  |

对于整数数据类型可以表示的长度范围需要记忆的有各类型所占字节数，以及范围：byte 型（-128 ~ 127）、short 型（-32768 ~ 32767）、int 型（正负都可表示二十亿以内的数）。如果上述三种类型都没有办法满足你的需求，那我肯定你需要使用 long 型。

**值得注意的是如果要使用 long 型，需要在数值后加上一个后缀 l（或 L ）。**

自 Java 7 开始，可以在表示数值时在数值中间添加下划线，编译器会自行无视这些下划线，其目的是为了增强可读性。

```java
long bigNum = 1_0000_0000_0000_0000_0000L;
```

> Java 没有任何无符号型（unsigned）形式的 byte、int、short 或 long 类型。
>
> . . .
>
> 需要调用 Byte.toUnsignedInt(b) 来得到一个 0 到 255 的 int 值，
>
> . . .

##### 1. 2. 1. 1 不同进制的表示

我们可以在变量的数值前加上不同的前缀来表示这个数值是其它的进制值。

```java
int hNum = 0xf0;	// hexadecimal number 十六进制数 表示16
int dNum = 10;		// decimal number 十进制数 表示10
int oNum = 010;		// octal number 八进制数 表示8
int bNum = 0b10;	// binary number 二进制数 表示2 （该表示方法需要Java版本为7或以上）
```

我为什么不在其它数据类型的位置或者另起小节介绍不同进制的表示呢？因为在整数数据类型中应用最多，而字符型也是以整数数据类型的十六进制来表示字符的。浮点数也可以用其它进制来表示（如 0x1.0p-3 表示 0.125 ），但是很罕见。

#### 1. 2. 2 对于浮点数（含小数的数）

Java 拥有两种表示浮点数的类型。

| Type Name | Type Size |
| :-------: | :-------: |
|   float   |  4 bytes  |
|  double   |  8 bytes  |

对于浮点数的记忆，float 型占 4 字节，而 double 是 float 的两倍，故为 double 型，这也是 float 为单精度而 double 为双精度名称的原因。float 的小数有效表示位数仅为 6 ~ 7 位小数，而 double 型则是 15 位。

**值得注意的是如果要使用 float 型，需要在数值后加上一个后缀 f（或 F ）。**

浮点数还有一个特殊的表示方法（科学计数法）：1.234e2（即为123.4）。

**浮点数无法在二进制中被精确的表示！**因此我们如果要进行无法接受精度误差的运算时应当采用 BigInteger 和 BigDecimal 类来处理。

#### 1. 2. 3 对于字符

| Type Name | Type Size |
| :-------: | :-------: |
|   char    |  2 bytes  |

Java 的字符型占 2 字节，这是因为设计 Java 时使用了 16 位的 [Unicode](..\computer\浅谈编码) 编码，Unicode 可以使用 4 位的 16 进制数表示（当然对应范围内的其它进制表示也同样可行），其范围为 \u0000 ~ \uffff （0 ~ 65535） 。

Java 采用的 Unicode 编码与现如今的 Unicode 编码已经并不相同了。

> 在 1991 年发布了 Unicode 1.0，当时仅占用 65 536 个代码值中不到一半的部分。
>
> . . .
>
> 十分遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode 字符超过了 65536 个，其主要的原因是增加了大量的汉语、日语和韩语中的表意文字。

> （第十万个字符在2005年获采纳）
>
> Unicode至今仍在不断增修，每个新版本都加入更多新的字符。

> **基本字符**表示从 U+0000 到 U+FFFF 之间的字符集，也被成为基本多语言面（BMP)。
>
> **增补字符**表示从 U+10000 到 U+10FFFF 范围之间的字符集，也就是原来的 16 位设计无法表示的字符。

我们可以通过上引文了解到 Java 通过 char 能表示的仅有基本字符，《 Java 核心技术 》也强调强烈不推荐使用 char 类型，它有很大的局限性。

需要注意的是 \u 后紧跟的四位十六进制数是 Unicode 的转义序列，

> 它会在解析代码之前得到处理，这意味着如果你在注释中写道 C:\users 则会产生一个语法错误，因为 \u 后面没有跟着四个十六进制数。

#### 1. 2. 4 对于条件

Java 中表示判断的两种条件状态的类型是 boolean。

| Type Name | Type Size |
| :-------: | :-------: |
|  boolean  |  1 byte   |

boolean 型仅有两个值用于逻辑判断，但是值得注意的是整数值和 boolean 型值之间无法转换。

#### 1. 2. 5 对于常量

Java 中表示常量仅需要将 final 关键字置于原先定义格式最前即可，常量只能被定义一次，在程序中无法被修改。

```java
public final static double PI = 3.1415926;
```

### 1. 3 引用类型

> 引用类型指向一个对象，指向对象的变量是引用变量

相关的概念和用法在 OOP 中体现。

## 2 变量类型

变量类型与数据类型并不相同，变量类型主要描述的是

### 2. 1 局部变量

局部变量是指在类中方法、构造方法或语句块中定义的变量。

局部变量在方法或语句块执行完后就会被丢弃，同时访问修饰符不能修饰它。

**没有类型默认值。需要初始化，不然直接引用时编译器会认为这是一个错误。**

### 2. 2 实例变量

实例变量是指在类中，但是不在方法、构造方法或语句块中定义的，且没有被 static 修饰的变量。

当这个类被实例化为一个对象时，实例变量的值也随之确定，实例变量在对象的生命周期内生存。可以被访问修饰符修饰（一般设为 private）。

**有类型默认值（但不意味着每次都不需要初始化）。**

### 2. 3 静态变量

静态变量是指在类中，但是不在方法、构造方法或语句块中定义的，且被 static 修饰的变量。

当类被加载时，静态变量就可以被访问，并且生存到程序结束。并且所有实例化的对象都共享这一份静态变量的值，他是独立于该类的任何对象的。可以被访问修饰符修饰（一般设为 public）。

**有类型默认值（同 2. 2）。**

## 3 运算（省略）

对于运算，它是程序中最经常使用的东西之一，因此只说明一个有意思的点，不系统的整理。

当你使用 任意整数 / 0 时，编译器则会报错：

```
java.lang.ArithmeticException: / by zero
```

但是如果你使用 任意浮点数 / 0 时，打印则会得到结果：

```
Infinity
```

## 4 流程控制（省略）

对于流程控制同样不作系统的整理。

对于 for 循环：

>  有一个不成文的规则：for 语句的 3 个部分应该对同一个计数器变量进行初始化、检测和更新。若不遵守这一规则，编写的循环常常晦涩难懂。

> 在循环中，检测两个浮点数是否相等需要格外小心。下面的 for 循环
>
> ```java
> for (double x = 0; x != 10; x += 0.1) . . .
> ```
>
> 可能永远不会结束。由于舍入的误差，可能永远达不到精确的最终值。例如，在上面的循环中，因为 0.1 无法精确的用二进制表示，所以，x 将从 9.999 999 999 999 98 跳到 10.099 999 999 999 98。